import jax
import jax.numpy as jnp
from jax import jit
from functools import partial
    

def get_fourier_mode_indices(P: int) -> jax.Array:
    """
    Generates a 1D array of Fourier mode indices centered around zero.

    For example:
    - If P=5, returns [-2, -1, 0, 1, 2]
    - If P=4, returns [-2, -1, 0, 1]

    Args:
        P: The total number of Fourier modes along a single dimension.

    Returns:
        A JAX array of integer indices.
    """
    return jnp.arange(P) - P // 2

def fourier_modes(*n_modes: int) -> jax.Array:
    """
    Generates N-dimensional Fourier mode vectors.

    These modes are designed to be used in the exponent of a complex exponential
    as part of a Fourier series, specifically for terms like exp(-1j * k_vec @ x_vec).

    Args:
        *n_modes: A variable number of integers, where each integer represents
                  the number of modes along a specific dimension. The number of
                  arguments defines the dimensionality N.

    Returns:
        A JAX array of shape (P, N), where P is the total number of modes
        (product of n_modes) and N is the dimensionality. Each row is an
        N-dimensional Fourier mode vector. The modes are multiplied by -1j
        as per the original function's definition for direct use in
        `jnp.exp(fourier_modes @ x)`.
    """
    # Get indices for each dimension, e.g., for n_modes=(3, 4), this will be
    # [jnp.array([-1, 0, 1]), jnp.array([-2, -1, 0, 1])]
    indices_per_dim = [get_fourier_mode_indices(n) for n in n_modes]

    # Create a meshgrid for N-dimensions.
    # jnp.meshgrid returns N arrays, each of shape (n_modes_0, n_modes_1, ..., n_modes_N-1).
    mesh_arrays = jnp.meshgrid(*indices_per_dim, indexing='ij')

    # Stack them along a new last axis. This results in an array of shape
    # (n_modes_0, n_modes_1, ..., n_modes_N-1, N).
    modes_stacked = jnp.stack(mesh_arrays, axis=-1)
    
    # Flatten the first N dimensions to get a 2D array of shape (P, N),
    # where P is the total number of unique N-dimensional mode combinations.
    P_total = jnp.prod(jnp.array(n_modes)) # Calculate total number of modes
    modes_reshaped = modes_stacked.reshape(P_total, len(n_modes))

    # Multiply by -1j and cast to complex64 as per the original function's definition.
    # This prepares the modes for direct use in `jnp.exp(f_modes @ x)`.
    return -1j * modes_reshaped.astype(jnp.complex64)

def fourier_design_matrix(
    x: jax.Array,        # (N, M) array of M N-dimensional spatial locations
    n_modes: jax.Array   # (N,) array of integers, number of modes per dimension
) -> jax.Array:
    """
    Constructs the Fourier design matrix for a real-valued signal.

    This function transforms the complex exponential basis (A_complex) into a
    real-valued basis (A_real), which is useful when fitting real-valued data
    with a Fourier series. The transformation assumes that the `fourier_modes`
    are symmetrically ordered around zero (as generated by `fourier_modes` function).

    The resulting matrix A_real has dimensions (M, P_real), where M is the
    number of data points and P_real is the number of real basis functions.

    Args:
        x: (N, M) JAX array where N is the dimension and M is the number of data points.
           Each column represents an N-dimensional coordinate (e.g., time, (x,y), (x,y,z)).
        n_modes: (N,) JAX array of integers, specifying the number of Fourier modes
                 along each of the N dimensions.

    Returns:
        (M, P_real) JAX array representing the real-valued design matrix.
    """
    # Ensure x is at least 2D, handling cases where x might be 1D initially.
    x = jnp.atleast_2d(x)
    n_dim, n_data = x.shape
    
    f_modes = fourier_modes(*n_modes)

    A_complex = jnp.exp(f_modes @ x).T

    s = A_complex.shape[1] // 2 + 1
    #real_parts = 0.5 * jnp.real(A_complex[:, :s] + A_complex[:, s:])
    real_parts = jnp.real(A_complex[:, :s])
    imag_parts = -jnp.imag(A_complex[:, s:])

    # Concatenate these two parts horizontally to form the final real-valued design matrix.
    A_real = jnp.concatenate([real_parts, imag_parts], axis=1)
    
    return A_real

def fourier_matvec(x, f_modes):
    A_complex = jnp.exp(f_modes @ x).T

    s = A_complex.shape[1] // 2 + 1
    #real_parts = 0.5 * jnp.real(A_complex[:, :s] + A_complex[:, s:])
    real_parts = jnp.real(A_complex[:, :s])
    imag_parts = -jnp.imag(A_complex[:, s:])

    # Concatenate these two parts horizontally to form the final real-valued design matrix.
    return jnp.concatenate([real_parts, imag_parts], axis=1)
